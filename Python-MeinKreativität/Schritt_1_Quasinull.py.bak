#Wenn zwei Elemente sind näher, welche Wechseln tritten zwischenbeiden ein?
Klasse = ['Umgebung', 'C-H-O-N-P-S'] # Environment and 'Pseudo Chemical Elements, Carbon, Hydrogeny, etc..
Reihe = ['A','n','a']
print(Reihe)
print(Klasse)

print #<built-in function print>
help(print)
"""Help on built-in function print in module builtins:

print(...)
    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)

    Prints the values to a stream, or to sys.stdout by default.
    Optional keyword arguments:
    file:  a file-like object (stream); defaults to the current sys.stdout.
    sep:   string inserted between values, default a space.
    end:   string appended after the last value, default a newline.
    flush: whether to forcibly flush the stream.
"""
dir()	#['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']
S = """\
... [1] Eigentlich sind Funktionsdefinitionen auch ‘Anweisungen’, die ‘ausgeführt’ werden; die Ausführung einer Funktionsdefinition auf Modulebene fügt den Funktionsnamen in die globale Symboltabelle des Moduls ein."""
type(S)
print(S)
len(S) # 211
# S.reverse() falhou, pois 'str' object has no attribute 'reverse'

Zk = str(S)

Zk.strip() # Um erro de grafia, mas experimente!

S1 = "Oft will man mehr Kontrolle über die Formatierung der Ausgabe haben als nur Leerzeichen-getrennte Werte auszugeben. Es gibt zwei Arten die Ausgabe zu formatieren: Die erste Möglichkeit ist, dass man die gesamte Verarbeitung der Zeichenketten selbst übernimmt; indem man Slicing- und Verknüpfungsoperationen benutzt, kann man jede denkbare Anordnung zusammenstellen. Der Typ string hat einige Methoden, die ein paar nützliche Operationen ausführen, um Zeichenketten auf eine bestimmte Länge aufzufüllen; diese werden wir in Kürze behandeln. Die zweite Möglichkeit ist die Benutzung der format() -Methode."

print(S1)
