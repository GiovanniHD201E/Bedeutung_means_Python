Abra o arquivo InterfaceF5.py na pasta Documentos/GitHub/Multifokus/PrototypApp.


Python 3.8.0 (tags/v3.8.0:fa919fd, Oct 14 2019, 19:37:50) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license()" for more information.
>>> 
= RESTART: C:/Users/Giova/Documents/GitHub/Multifokus/PrototypApp/Interface.py =
Digite o artigo com letra maiÃºscula   O
Digite o substantivo   Folha
A Folha
>>> print()

>>> return
SyntaxError: 'return' outside function
>>> dir
<built-in function dir>
>>> dir()
['Angela1', '__annotations__', '__builtins__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']
>>> __name__
'__main__'
>>> __main__
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    __main__
NameError: name '__main__' is not defined
>>> name
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    name
NameError: name 'name' is not defined
>>> __package__
>>> __spec__
>>> __file__
'C:/Users/Giova/Documents/GitHub/Multifokus/PrototypApp/Interface.py'
>>> __doc__
>>> __loader__
<class '_frozen_importlib.BuiltinImporter'>
>>> Angela1
<module 'Angela1' from 'C:/Users/Giova/Documents/GitHub/Multifokus/PrototypApp\\Angela1.py'>
>>> help(Angela1)
Help on module Angela1:

NAME
    Angela1

DATA
    A = 'A '
    ArtdoGen = {'F': 'O ', 'M': 'A '}
    CapturaGenArt = 'M'
    CapturaGenSub = 'F'
    GA = 'M'
    GS = 'F'
    GendoArt = {'A': 'F', 'O': 'M'}
    GendoSub = {'Apontador': 'M', 'Bolsa': 'F', 'Cadeira': 'F', 'Caderno':...
    S = 'Folha'

FILE
    c:\users\giova\documents\github\multifokus\prototypapp\angela1.py


>>> help(__name__)
Help on module __main__:

NAME
    __main__

DATA
    __annotations__ = {}

FILE
    c:\users\giova\documents\github\multifokus\prototypapp\interface.py


>>> help()

Welcome to Python 3.8's help utility!

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at https://docs.python.org/3.8/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules.  To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, symbols, or topics, type
"modules", "keywords", "symbols", or "topics".  Each module also comes
with a one-line summary of what it does; to list the modules whose name
or summary contain a given string such as "spam", type "modules spam".

help> Angela1
Help on module Angela1:

NAME
    Angela1

DATA
    A = 'A '
    ArtdoGen = {'F': 'O ', 'M': 'A '}
    CapturaGenArt = 'M'
    CapturaGenSub = 'F'
    GA = 'M'
    GS = 'F'
    GendoArt = {'A': 'F', 'O': 'M'}
    GendoSub = {'Apontador': 'M', 'Bolsa': 'F', 'Cadeira': 'F', 'Caderno':...
    S = 'Folha'

FILE
    c:\users\giova\documents\github\multifokus\prototypapp\angela1.py


help> 

You are now leaving help and returning to the Python interpreter.
If you want to ask for help on a particular object directly from the
interpreter, you can type "help(object)".  Executing "help('string')"
has the same effect as typing a particular string at the help> prompt.
>>> dir(Angela1)
['A', 'ArtdoGen', 'CapturaGenArt', 'CapturaGenSub', 'GA', 'GS', 'GendoArt', 'GendoSub', 'S', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']
>>> print(Angela1)
<module 'Angela1' from 'C:/Users/Giova/Documents/GitHub/Multifokus/PrototypApp\\Angela1.py'>
>>> Angela1[0]
Traceback (most recent call last):
  File "<pyshell#18>", line 1, in <module>
    Angela1[0]
TypeError: 'module' object is not subscriptable
>>> dir(Angela1[0])
Traceback (most recent call last):
  File "<pyshell#19>", line 1, in <module>
    dir(Angela1[0])
TypeError: 'module' object is not subscriptable
>>> Angela1(1)
Traceback (most recent call last):
  File "<pyshell#20>", line 1, in <module>
    Angela1(1)
TypeError: 'module' object is not callable
>>> dir()
['Angela1', '__annotations__', '__builtins__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']
>>> dir([1])
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>> Angela1.copy()
Traceback (most recent call last):
  File "<pyshell#23>", line 1, in <module>
    Angela1.copy()
AttributeError: module 'Angela1' has no attribute 'copy'
>>> Angela1.A
'A '
>>> Angela1.Angela1
Traceback (most recent call last):
  File "<pyshell#25>", line 1, in <module>
    Angela1.Angela1
AttributeError: module 'Angela1' has no attribute 'Angela1'
>>> Angela1.ArtdoGen
{'M': 'A ', 'F': 'O '}
>>> ArtdoGen
Traceback (most recent call last):
  File "<pyshell#27>", line 1, in <module>
    ArtdoGen
NameError: name 'ArtdoGen' is not defined
>>> help(Angela1.ArtdoGen)
Help on dict object:

class dict(object)
 |  dict() -> new empty dictionary
 |  dict(mapping) -> new dictionary initialized from a mapping object's
 |      (key, value) pairs
 |  dict(iterable) -> new dictionary initialized as if via:
 |      d = {}
 |      for k, v in iterable:
 |          d[k] = v
 |  dict(**kwargs) -> new dictionary initialized with the name=value pairs
 |      in the keyword argument list.  For example:  dict(one=1, two=2)
 |  
 |  Methods defined here:
 |  
 |  __contains__(self, key, /)
 |      True if the dictionary has the specified key, else False.
 |  
 |  __delitem__(self, key, /)
 |      Delete self[key].
 |  
 |  __eq__(self, value, /)
 |      Return self==value.
 |  
 |  __ge__(self, value, /)
 |      Return self>=value.
 |  
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |  
 |  __getitem__(...)
 |      x.__getitem__(y) <==> x[y]
 |  
 |  __gt__(self, value, /)
 |      Return self>value.
 |  
 |  __init__(self, /, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __iter__(self, /)
 |      Implement iter(self).
 |  
 |  __le__(self, value, /)
 |      Return self<=value.
 |  
 |  __len__(self, /)
 |      Return len(self).
 |  
 |  __lt__(self, value, /)
 |      Return self<value.
 |  
 |  __ne__(self, value, /)
 |      Return self!=value.
 |  
 |  __repr__(self, /)
 |      Return repr(self).
 |  
 |  __reversed__(self, /)
 |      Return a reverse iterator over the dict keys.
 |  
 |  __setitem__(self, key, value, /)
 |      Set self[key] to value.
 |  
 |  __sizeof__(...)
 |      D.__sizeof__() -> size of D in memory, in bytes
 |  
 |  clear(...)
 |      D.clear() -> None.  Remove all items from D.
 |  
 |  copy(...)
 |      D.copy() -> a shallow copy of D
 |  
 |  get(self, key, default=None, /)
 |      Return the value for key if key is in the dictionary, else default.
 |  
 |  items(...)
 |      D.items() -> a set-like object providing a view on D's items
 |  
 |  keys(...)
 |      D.keys() -> a set-like object providing a view on D's keys
 |  
 |  pop(...)
 |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
 |      If key is not found, d is returned if given, otherwise KeyError is raised
 |  
 |  popitem(self, /)
 |      Remove and return a (key, value) pair as a 2-tuple.
 |      
 |      Pairs are returned in LIFO (last-in, first-out) order.
 |      Raises KeyError if the dict is empty.
 |  
 |  setdefault(self, key, default=None, /)
 |      Insert key with a value of default if key is not in the dictionary.
 |      
 |      Return the value for key if key is in the dictionary, else default.
 |  
 |  update(...)
 |      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
 |      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
 |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
 |      In either case, this is followed by: for k in F:  D[k] = F[k]
 |  
 |  values(...)
 |      D.values() -> an object providing a view on D's values
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  fromkeys(iterable, value=None, /) from builtins.type
 |      Create a new dictionary with keys from iterable and values set to value.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  __new__(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

>>> 